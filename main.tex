\documentclass[letterpaper]{article} % DO NOT CHANGE THIS
\usepackage[submission]{aaai2026}  % DO NOT CHANGE THIS
\usepackage{times}  % DO NOT CHANGE THIS
\usepackage{helvet}  % DO NOT CHANGE THIS
\usepackage{courier}  % DO NOT CHANGE THIS
\usepackage[hyphens]{url}  % DO NOT CHANGE THIS
\usepackage{graphicx} % DO NOT CHANGE THIS
\urlstyle{rm} % DO NOT CHANGE THIS
\def\UrlFont{\rm}  % DO NOT CHANGE THIS
\usepackage{natbib}  % DO NOT CHANGE THIS AND DO NOT ADD ANY OPTIONS TO IT
\usepackage{caption} % DO NOT CHANGE THIS AND DO NOT ADD ANY OPTIONS TO IT
\frenchspacing  % DO NOT CHANGE THIS
\setlength{\pdfpagewidth}{8.5in} % DO NOT CHANGE THIS
\setlength{\pdfpageheight}{11in} % DO NOT CHANGE THIS
%
% These are recommended to typeset algorithms but not required. See the subsubsection on algorithms. Remove them if you don't have algorithms in your paper.
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath,amsfonts,amssymb}

%
% These are are recommended to typeset listings but not required. See the subsubsection on listing. Remove this block if you don't have listings in your paper.
\usepackage{newfloat}
\usepackage{listings}
\DeclareCaptionStyle{ruled}{labelfont=normalfont,labelsep=colon,strut=off} % DO NOT CHANGE THIS
\lstset{%
	basicstyle={\footnotesize\ttfamily},% footnotesize acceptable for monospace
	numbers=left,numberstyle=\footnotesize,xleftmargin=2em,% show line numbers, remove this entire line if you don't want the numbers.
	aboveskip=0pt,belowskip=0pt,%
	showstringspaces=false,tabsize=2,breaklines=true}
\floatstyle{ruled}
\newfloat{listing}{tb}{lst}{}
\floatname{listing}{Listing}
%
% Keep the \pdfinfo as shown here. There's no need
% for you to add the /Title and /Author tags.
\pdfinfo{
/TemplateVersion (2026.1)
}

% DISALLOWED PACKAGES
% \usepackage{authblk} -- This package is specifically forbidden
% \usepackage{balance} -- This package is specifically forbidden
% \usepackage{color (if used in text)
% \usepackage{CJK} -- This package is specifically forbidden
% \usepackage{float} -- This package is specifically forbidden
% \usepackage{flushend} -- This package is specifically forbidden
% \usepackage{fontenc} -- This package is specifically forbidden
% \usepackage{fullpage} -- This package is specifically forbidden
% \usepackage{geometry} -- This package is specifically forbidden
% \usepackage{grffile} -- This package is specifically forbidden
% \usepackage{hyperref} -- This package is specifically forbidden
% \usepackage{navigator} -- This package is specifically forbidden
% (or any other package that embeds links such as navigator or hyperref)
% \indentfirst} -- This package is specifically forbidden
% \layout} -- This package is specifically forbidden
% \multicol} -- This package is specifically forbidden
% \nameref} -- This package is specifically forbidden
% \usepackage{savetrees} -- This package is specifically forbidden
% \usepackage{setspace} -- This package is specifically forbidden
% \usepackage{stfloats} -- This package is specifically forbidden
% \usepackage{tabu} -- This package is specifically forbidden
% \usepackage{titlesec} -- This package is specifically forbidden
% \usepackage{tocbibind} -- This package is specifically forbidden
% \usepackage{ulem} -- This package is specifically forbidden
% \usepackage{wrapfig} -- This package is specifically forbidden
% DISALLOWED COMMANDS
% \nocopyright -- Your paper will not be published if you use this command
% \addtolength -- This command may not be used
% \balance -- This command may not be used
% \baselinestretch -- Your paper will not be published if you use this command
% \clearpage -- No page breaks of any kind may be used for the final version of your paper
% \columnsep -- This command may not be used
% \newpage -- No page breaks of any kind may be used for the final version of your paper
% \pagebreak -- No page breaks of any kind may be used for the final version of your paperr
% \pagestyle -- This command may not be used
% \tiny -- This is not an acceptable font size.
% \vspace{- -- No negative value may be used in proximity of a caption, figure, table, section, subsection, subsubsection, or reference
% \vskip{- -- No negative value may be used to alter spacing above or below a caption, figure, table, section, subsection, subsubsection, or reference

% User-added config
\graphicspath{{ ./images }}
\usepackage{subcaption}
\usepackage{cite}

\setcounter{secnumdepth}{2} %May be changed to 1 or 2 if section numbers are desired.

% The file aaai2026.sty is the style file for AAAI Press
% proceedings, working notes, and technical reports.
%

% Title

% Your title must be in mixed case, not sentence case.
% That means all verbs (including short verbs like be, is, using,and go),
% nouns, adverbs, adjectives should be capitalized, including both words in hyphenated terms, while
% articles, conjunctions, and prepositions are lower case unless they
% directly follow a colon or long dash
\title{Quantum Circuit Synthesis with Deep Reinforcement Learning and Heuristic Search}
\author{
    %Authors
    % All authors must be in the same font size and format.
    Written by AAAI Press Staff\textsuperscript{\rm 1}\thanks{With help from the AAAI Publications Committee.}\\
    AAAI Style Contributions by Pater Patel Schneider,
    Sunil Issar,\\
    J. Scott Penberthy,
    George Ferguson,
    Hans Guesgen,
    Francisco Cruz\equalcontrib,
    Marc Pujol-Gonzalez\equalcontrib
}
\affiliations{
    %Afiliations
    \textsuperscript{\rm 1}Association for the Advancement of Artificial Intelligence\\
    % If you have multiple authors and multiple affiliations
    % use superscripts in text and roman font to identify them.
    % For example,

    % Sunil Issar\textsuperscript{\rm 2},
    % J. Scott Penberthy\textsuperscript{\rm 3},
    % George Ferguson\textsuperscript{\rm 4},
    % Hans Guesgen\textsuperscript{\rm 5}
    % Note that the comma should be placed after the superscript

    1101 Pennsylvania Ave, NW Suite 300\\
    Washington, DC 20004 USA\\
    % email address must be in roman text type, not monospace or sans serif
    proceedings-questions@aaai.org
%
% See more examples next
}

%Example, Single Author, ->> remove \iffalse,\fi and place them surrounding AAAI title to use it
\iffalse
\title{My Publication Title --- Single Author}
\author {
    Author Name
}
\affiliations{
    Affiliation\\
    Affiliation Line 2\\
    name@example.com
}
\fi

\iffalse
%Example, Multiple Authors, ->> remove \iffalse,\fi and place them surrounding AAAI title to use it
\title{My Publication Title --- Multiple Authors}
\author {
    % Authors
    First Author Name\textsuperscript{\rm 1},
    Second Author Name\textsuperscript{\rm 2},
    Third Author Name\textsuperscript{\rm 1}
}
\affiliations {
    % Affiliations
    \textsuperscript{\rm 1}Affiliation 1\\
    \textsuperscript{\rm 2}Affiliation 2\\
    firstAuthor@affiliation1.com, secondAuthor@affilation2.com, thirdAuthor@affiliation1.com
}
\fi


% REMOVE THIS: bibentry
% This is only needed to show inline citations in the guidelines document. You should not need it and can safely delete it.
\usepackage{bibentry}
% END REMOVE bibentry

\begin{document}

\maketitle

\begin{abstract}
% TODO: accentuate competitive (and sometimes superior) in terms of coverage, gate count, and time
% TODO: can change title to focus on Clifford + T?
Quantum circuit synthesis is the process of implementing
a quantum algorithm with a given gate set. In this
paper, we first show how this problem can be posed as a
pathfinding problem. Next, we use DeepCubeA to learn a
heuristic function for quantum circuit synthesis for one and
two qubit circuits with deep reinforcement learning and
solve problem instances with batch weighed A* search. We
compare our approach against a state-of-the-art
quantum circuit synthesis tool and show that are our
approach is competitive.
\end{abstract}



%% SECTION Introduction
\section{Introduction}


\begin{figure}[h!]
	\centering
	\includegraphics[width=0.44\textwidth]{images/qc_ex.png}
	\caption{Example of a quantum circuit composed of Clifford and T gates}
	\label{fig:toffoli}
\end{figure}

The realization of quantum algorithms on real-world quantum computers is accomplished through
quantum compiling \cite{maronese2022quantum}, also known as quantum circuit synthesis.
Given a quantum algorithm, quantum compiling finds a quantum circuit that implements that algorithm.
A quantum algorithm can be represented as a matrix of size $2^n \times 2^n$, with $n$ being the number of qubits.
A quantum circuit (Figure \ref{fig:toffoli}) is a sequence of gates that perform operations on one or more qubits,
where a qubit is an irreducible unit of quantum information.
Given a quantum circuit, the matrix that represents the algorithm it implements is obtained by starting with the
identity matrix and changing its entries according to matrix multiplications determined by the gates used in the circuit.
As a result, quantum compiling can be posed as a pathfinding problem, where the start state
is the identity matrix, the goal is a given quantum algorithm, the transitions are quantum gates, and the transition costs
are determined by a combination of quantum gate execution time and the noise the gate introduces.


Finding quantum circuits that implement a given algorithm is a non-trivial task that can sometimes take state-of-the-art
methods several hours, even for single qubit operators \cite{paradis2024synthetiq}.
Given that we can pose this as a pathfinding problem, we build on the DeepCubeA algorithm \cite{agostinelli2019solving}
and hindsight experience replay (HER) \cite{andrychowicz2017hindsight} to use deep reinforcement learning to learn
a heuristic function that maps a given quantum circuit and quantum goal algorithm to an estimate of the cost of a
shortest path (i.e. ``cost-to-go'') from the given circuit to a circuit that implements the goal algorithm.
Previous work that has built on DeepCubeA to perform quantum compiling used the reversibility of quantum gates
to set the starting state to be the quantum algorithm and the goal to be the identity matrix
\cite{zhang2020topological,bao2024twisty,chen2024efficient}.
Our work distinguishes itself from this previous work since the starting state is the identity matrix and the goal is
given as the quantum algorithm.
This distinction then allows our approach to be modified for the specification of goals as
a set of goal states through partial specification of goal matrix entries or through abstraction using formal logic.
This may be necessary if certain properties of the algorithm (i.e. entries in the matrix) are known while other parts are not
known or not relevant.
These modifications that allow for this are already present in existing literature \cite{agostinelli2024specifying}
and can be applied to the work presented in the paper.




%% SECTION Background
\section{Background}


\subsection{Quantum Computing}


\paragraph{Qubits}

A qubit is the fundamental unit of information in quantum computing.
We can represent any system of $n$ qubits as a unit vector $|\psi\rangle \in \mathbb{C}^{2^n}$.
The $0$ and $1$ states for a single qubit can be represented as

\begin{equation}
	|0\rangle = \begin{bmatrix} 1 \\ 0 \end{bmatrix}
	,~~~~
	|1\rangle = \begin{bmatrix} 0 \\ 1 \end{bmatrix}
\end{equation}

and a general one-qubit quantum state can be represented as $\alpha|0\rangle + \beta|1\rangle$,
where $\alpha,\beta\in\mathbb{C}$ and $|\alpha|^2+|\beta|^2=1$.
It is important to note that if two quantum state vectors differ only by a complex
phase (meaning $|\psi\rangle=e^{i\theta}|\phi\rangle$ for two state vectors $|\psi\rangle$ and $|\phi\rangle$),
then the two states cannot be distinguished in any way by measurement.
For this reason, it is common to disregard global phases in calculations or modify them as needed for convenience
\cite{nielsen2010quantum}.


Multiple qubit systems can be represented using the tensor product.
The tensor product between two matrices $A \in \mathbb{C}^{m_1 \times n_1},B \in \mathbb{C}^{m_2 \times n_2}$
is defined as the block matrix
\begin{equation}
	A \otimes B =
	\begin{bmatrix}
		a_{11} B   & \dots  & a_{1n_1} B    \\
		\vdots     & \ddots & \vdots        \\
		a_{m_11} B & \dots  &  a_{m_1n_1} B \\
	\end{bmatrix}
	\in \mathbb{C}^{m_1m_2 \times n_1n_2}
\end{equation}
where $a_{ij}$ is the $i,j$-the element of the matrix $A$.
The basis states of an $n$-qubit system can be represented as a tensor product of $n$ one-qubit states,
for example $|011\rangle = |0\rangle \otimes |1\rangle \otimes |1\rangle$.


\paragraph{Gates}

Quantum gates transform quantum states into new states.
Disregarding measurement operations, a quantum gate can be represented by a unitary matrix $U \in \mathbb{C}^{2^n \times 2^n}$.
A matrix is unitary if $UU^{\dagger}=U^{\dagger}U=I$, where $U^{\dagger}$ is the conjugate transpose of $U$.
As a consequence of the global phase invariance of quantum states, two circuits whose unitaries differ only by a complex
phase are also considered equivalent.
If a unitary is applied to only a subset of the qubits in a state, then the entire operation can be represented
as a tensor product of the unitary and the identity matrix on the other qubits, for example the matrix
$I \otimes I \otimes U$ represents the unitary $U$ applied to the third qubit in a three qubit quantum state, and no operation
applied to the first and second qubits.


There are many methods for calculating the `distance' between two unitary operators.
In this paper we use the Hilbert-Schmidt distance function

\begin{equation}
	d(U,V) = \sqrt{1 - \frac{1}{4^n} |Tr(U^{\dagger}V)|^2}
\end{equation}

This method has the advantage that if two unitaries $A$ and $B$ differ only by a global phase, then $d(A,B)=0$.


\paragraph{Clifford+T Gate Set}

If a finite set of gates is universal, then any unitary can be approximated by a finite sequence
of those gates up to any arbitrary tolerance value $\epsilon$ \cite{nielsen2010quantum}.
The most commonly studied discrete gate set is the Clifford+T set, as it is considered likely that the Clifford+T
set will be the basis of fault-tolerant quantum computing.
The set is a union of the Clifford gate set and the $T$ gate.
The Clifford set can be generated (via matrix multiplication and the tensor product) by the three Pauli matrices
\begin{equation}
	X =
	\begin{bmatrix}
		0 & 1 \\
		1 & 0
	\end{bmatrix}
	,~~
	Y =
	\begin{bmatrix}
		0 & -i \\
		i & 0
	\end{bmatrix}
	,~~
	Z =
	\begin{bmatrix}
		1 & 0 \\
		0 & -1
	\end{bmatrix}
\end{equation}
and the Hadamard and $S$ gates
\begin{equation}
	H =
	\frac{1}{\sqrt{2}}
	\begin{bmatrix}
		1 & 1 \\
		1 & -1
	\end{bmatrix}
	,~~
	S =
	\begin{bmatrix}
		1 & 0 \\
		0 & i
	\end{bmatrix}
\end{equation}
and, in the case of multi-qubit circuits, the two-qubit gate CNOT
\begin{equation}
	\text{CNOT} =
	\begin{bmatrix}
		1 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 0 & 0 & 1 \\
		0 & 0 & 1 & 0
	\end{bmatrix}.
\end{equation}
Note that this is not the only generating gate set for the Clifford operators.
Since the Clifford set is not universal (it only generates a finite number of unique circuits),
we must add the $T$ gate
\begin{equation}
	T =
	\begin{bmatrix}
		1 & 0 \\
		0 & e^{i\frac{\pi}{4}}
	\end{bmatrix}.
\end{equation}
With the addition of the $T$ gate, the set will be able to approximate any unitary.



\begin{figure*}
	\begin{subfigure}{0.2\textwidth}
		\includegraphics[width=\textwidth]{images/qc_U}
		\caption{Arbitrary 2-qubit unitary}
	\end{subfigure}
	\begin{subfigure}{0.76\textwidth}
		\includegraphics[width=\textwidth]{images/qc_U3}
		\caption{Unitary decomposed into arbitrary 1-qubit unitaries and CNOTs}
	\end{subfigure}
	\\
	\begin{subfigure}{\textwidth}
		\includegraphics[width=\textwidth]{images/qc_tr}
		\caption{Final compiled circuit after synthesizing each 1-qubit unitary with \textbf{trasyn}}
	\end{subfigure}
	\caption{Process for synthesis of multi-qubit circuits using \textbf{trasyn}}
	\label{fig:trasyn_multi_process}
\end{figure*}


\paragraph{Unitary Synthesis}

Given that discrete gate sets such as Clifford+T are likely to be the basis of near-term fault-tolerant quantum computing,
methods that can synthesize arbitrary unitaries from these discrete gate sets are needed.
The problem of unitary synthesis is this: given a unitary specifiation $U$, find a sequence of gates
${g_1,...,g_n}$ chosen from a discrete gate set that implements a unitary $V = g_1 \times \cdots \times g_n$
such that $d(U,V)\leq \epsilon$, where $\epsilon$ is the `tolerance' value of the compilation.
When $\epsilon > 0$, we classify the problem as approximate synthesis, and when $\epsilon=0$ we classify it as exact synthesis.



\subsection{Pathfinding}
Pathfinding is the process of finding a sequence of actions that forms a path between a given start state and a given goal, where a goal is a set of states considered goal states. A pathfinding domain is defined by a weighted directed graph, where nodes represent states, edges represent transitions between states, and weights represent transition costs \cite{pohl1970heuristic}. The transitions can be thought of as resulting from a set of actions, $\mathcal{A}$, and the transition function function, $T$, returns state, $s'$, given state, $s$, and action, $a$, if and only if there is an edge between state $s$ and $s'$ for some action, $a$ (i.e. $s' = T(s,a)$). The transition cost function, $c$, returns the cost of taking action, $a$, in states, $s$ (i.e. $c(s,a)$). Given a domain, a pathfinding problem instance is defined by a start state and a goal. Given a path that is a solution to a problem instance, the path cost is the sum of transition costs. In this work, the states are matrices representing quantum algorithms, transitions are the application of quantum gates, which produce new matrices, and transition costs are 1 for all gates. In future work, we will consider assigning a higher transition cost to gates, such as the $T$ gate, which add more execution time or noise to the circuit.

\subsubsection{Heuristic Search}
A* search \cite{hart1968formal} is a search algorithm designed to find a path between two nodes in a weighted directed graph. Similar to other algorithms like depth-first search and Djikstra's algorithm, A* keeps a priority queue of nodes, ordered from least to greatest according
to the function
\begin{equation}
    f(n)=g(n)+h(n)
\end{equation}
where $g(n)$ is the path cost (sum of all transition costs taken to reach node
$n$ and $h(n)$ is the heuristic function value of state associated with $n$.

While searching each node keeps track of the path cost and heuristic function value
as well as a connection to its parent node and the action taken to generate the state from its parent. The A* search process is begun when a single node with no parents representing the start state is added to the queue, and is ended once a node associated with a goal state is selected for expansion or there are no more nodes to expand.

In practice, a significant speedup can be achieved with heuristic functions represented by neural networks by batching the expansion steps together and exploiting the parallelism of graphics processing units (GPUs), as well as modifying the cost function to be $f(n)=\lambda g(n)+h(n)$,
where $\lambda \in [0,1]$ can be adjusted to place less important on the path cost of a state and more on the heuristic value. This batched and weighted version of A* search is referred to as batch weighted A* search (BWAS).

\subsection{DeepCubeA}

DeepCubeA \cite{agostinelli2019solving} is an algorithm that learns a domain-specific heuristic function represented as a deep neural network (DNN) \cite{schmidhuber2015deep,lecun2015deep} using deep reinforcement learning \cite{sutton2018reinforcement}, which is then used with BWAS to solve problem instances. While DeepCubeA originally assumed the goal was known before training and took transitions in reverse from the goal, extensions have built on hindsight experience replay (HER) \cite{andrychowicz2017hindsight} to learn heuristic functions that generalize over both states and goals \cite{agostinelli2024specifying,agostinelli2024learning}.

\subsubsection{Learning the Heuristic Function}
The heuristic function is learned with approximate value iteration \cite{puterman1978modified,bertsekas1996neuro}, which iteratively trains a model to approximate a Bellman update for a set of problem instances. The Bellman update, in the context of pathfinding (shown in Equation \ref{eq:bellmanup}) uses the Bellman optimality equation as an update rule. Approximate value iteration can be used to train a DNN, $h_\theta$, with parameters $\theta$, with gradient descent using the loss function in Equation \ref{eq:viloss}, where $N$ is the batch size. The heuristic function used to calculate the Bellman update in Equation \ref{eq:bellmanup} is $h_{\theta^-}$, where $\theta^-$ is the parameters of the target network \cite{mnih2015human} which are periodically updated to $\theta$. Approximate value iteration with DNNs is referred to as deep approximate value iteration (DAVI).

\begin{equation} \label{eq:bellmanup}
	\small
	h'(s,g) =
	\begin{cases}
		0, & \text{if } s \in g, \\
		\min\limits_{a \in \mathcal{A}}{c(s,a) + h(T(s,a),g)}, & \text{otherwise}.
	\end{cases}
\end{equation}


\begin{equation} \label{eq:viloss}
	L({\theta}) = \frac{1}{N}\sum_{i}^N{(h'(s_i,g_i) - h_{\theta}(s_i,g_i))^2}
\end{equation}


We build on hindsight experience replay (HER) \cite{andrychowicz2017hindsight} to generate start state and goal pairs without having to start from a predetermined goal and take actions in reverse. We accomplish this by first starting with the identity matrix and taking random actions to generate a start state. From this generated start state, we then take random actions to generate a goal state.




%% SECTION Related work
\section{Related Work}

Many methods for unitary synthesis have been explored with domain-specific synthesizers. The programs \textbf{synthetiq} \cite{paradis2024synthetiq}
and \textbf{trasyn} \cite{hao2025reducing} use a gate sampling search guided by the unitary distance function. The program \textbf{gridsynth} \cite{ross2014optimal} uses advanced domain-specific knowledge to analytically synthesize optimal circuits, but is limited to only one-qubit $R_z(\theta)$ gates. These methods all compile unitaries with the objective of reducing the number of  $T$ gates, given that $T$ gates are dramatically more expensive to produce on quantum hardware than the Clifford gates.


On the other hand, deep reinforcement learning and heuristic search has been used to synthesize quantum circuits. \citet{zhang2020topological} build on DeepCubeA to learn a heuristic function for topological quantum compilation of Fibonacci anyons. \cite{bao2024twisty} learn a heuristic function that is then used with beam search for Clifford gates. \cite{chen2024efficient} use deep Q-learning \cite{watkins1992q,mnih2015human} and Q* search \cite{agostinelli2024q} to perform one and two-qubit synthesis for Fibonacci anyons, HRC gate set \cite{harrow2002efficient}, and the Clifford + T gate set. \cite{weiden2025making} explores modifications to the neural networks
and training processes used in Clifford+T synthesis.  \citet{rietsch2024unitary} explores applications of reinforcement learning to Clifford + T synthesis for multiple qubits and find they are competitive with methods, such as synthetiq, in terms of gate length, but are 10 to 100 times slower for 2 and 3 qubits. 

In contrast with previous methods for Clifford+T synthesis, we first perform a systematic empirical study on what DNN encodings perform best for quantum circuit synthesis. After training the heuristic function, we use BWAS, to take advantage of paralellism provided by GPUs, which other methods often do not take advantage of. As a result, to the best of our knowledge, we are the first machine learning-based approach that is competitive with, and sometimes superior to, domain-specific programs, such as trasyn, in terms of gate count and search time. 

% While these previous approaches assume a fixed goal of the identity matrix and use reverse quantum gates to find a path from a specified algorithm to the identity, we instead find a path from the identity to the specified algorithm using the given gate set. This then allows future iterations of our work to include the specification of sets of goal states through partial goal specification or abstraction through formal logic \cite{agostinelli2024specifying,agostinelli2025conflict}, offering greater flexibility to practitioners and reducing the knowledge required to specify an algorithm.




%% SECTION Approach
\section{Approach}


\subsection{State Representation}


States are represented as unitary matrices.
These matrices are the product of the matrices of all the actions taken to get to the state, multiplied together.
We take advantage of the fact that unitary matrices are invertible, and multiply the inverse of the state matrix
with the goal matrix when giving it as input to the neural network.
We are allowed to do this because the problem of finding a matrix $M$ such that $MS=G$ is the the same as
finding a matrix $M$ such that $M=GS^{-1}$ (here $S$ is the matrix of the current state, $G$ is the matrix of the goal state,
and $M$ is the matrix representing the actions needed to go from the state to the goal).
This gives us the overall transformation from state to goal, which is also a unitary matrix.


To handle the global phase invariance property of quantum circuits, we project the unitaries into the
special unitary group, which is isomorphic to the unitary group up to a global phase.
This results in a function $\Pi : U(n) \rightarrow SU(n)$, defined as
$\Pi (A) = e^{-i (\arg(\text{det}(A)))/n} A$.
This ensures that states that differ only by a global phase will be represented equivalently when input to the neural network.


We explore three methods of representing the unitaries when inputting them into the neural network.
The first of these is simply to flatten the real and imaginary components of the matrix into a vector
and input them into the neural network.
The second is to convert them into quaternions,
however this approach is only valid for the single-qubit case,
which is represented by $SU(2)$.
The third is the generalized Euler angle encoding, which maps a unitary $U \in U(n)$ to a set of $n^2-1$ angles
which uniquely describe the matrix up to a global phase.
The quaternion and Euler angle representations are described in more detail in the appendix.


We also use Neural Radiance Field Encoding (NeRF) \cite{mildenhall2021nerf},
which was originally developed for image processing, but has been shown to improve neural network performance when
dealing with unitary matrices \cite{weiden2025making}.
NeRF encoding can be described as a function $\gamma : \mathbb{R} \rightarrow \mathbb{R}^{2L}$ that maps real numbers
to a vector of $2L$ real numbers, where $L$ is an arbitrary parameter.
The function is defined as
\begin{equation}
	\gamma(x) =
	\begin{bmatrix}
		\cos(2^0 x) \\
		\sin(2^0 x) \\
		\vdots \\
		\cos(2^{L-1} x) \\
		\sin(2^{L-1} x)
	\end{bmatrix}.
\end{equation}
It ensures that the input will be between $-1$ and $1$, and has the effect of amplifying small or high-frequency variations in
input data so that neural networks can perceive them, which has been shown to improve performance in a variety of domains.


\subsection{Training}



\begin{figure}
	\centering
	\includegraphics[width=0.48\textwidth]{images/training1q}
	\caption{Training progress for different state encoding methods on 1-qubit synthesis with $\epsilon=0.01$}
	\label{fig:training}
\end{figure}



\begin{figure*}
	\centering
	\begin{subfigure}{0.48\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/1q-bench}
		\caption{1-qubit synthesis with $\epsilon=0.01$}
	\end{subfigure}
	\begin{subfigure}{0.48\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/2q-bench}
		\caption{2-qubit synthesis with $\epsilon=0.5$}
	\end{subfigure}
	\caption{A* search vs \textbf{trasyn} for synthesis of arbitrary 1 and 2-qubit unitaries}
	\label{fig:benchmark}
\end{figure*}

We use HER to generate training examples and, additionally, attempt to solve problem instances with a greedy
policy using the target network and add states seen during solution attempts to the training set.
The heuristic function is then trained with DAVI.
After using HER to generate goal states,
we apply perturbations to each goal matrix $U$ to generate matrices $\tilde{U}$ such that $d(U,\tilde{U})\leq\epsilon$,
similar to the training process in \cite{weiden2025making}.
This has been shown to make the training process more robust to approximate synthesis.

After each update, we test our value function using a greedy policy.
This policy can be defined as
\begin{equation}
    \pi(s)=\underset{a\in \mathcal{A}}{\text{argmin}}(c(s,a)+h_{\theta}(T(s,a),s_g))
\end{equation}
where $s_g$ is the goal state. The greedy policy simply selects the state which minimizes the value of the heuristic function plus the transition cost for all possible next states. We record the percentage of test states solved by the greedy policy after each iteration, and update our target network parameters $\theta^-$ only when this percentage has surpassed the previous best.
A graph of the solved percentages after each training update is shown for several encoding methods in Figure \ref{fig:training}.




\subsection{Testing \& Verification}


For a testing dataset we use randomly generated 1000 unitaries on both one and two qubits using Qiskit.
We then run A* search and save the solved circuits in the OpenQASM format \cite{cross2022openqasm},
and import them into Qiskit to confirm their closeness to the original operators.



%% SECTION Experiments
\section{Experiments}


\subsection{Single-Qubit Synthesis}

For single-qubit synthesis we found the best performance with Euler angle encoding and NeRF with $L=15$.
Most of the performance boost was attributable to NeRF, although Euler angle encoding seems to lead to more
stable training and slightly better search results.
We trained a model for $\epsilon=0.01$, given that this is in the middle of the `comfort zone' for \textbf{trasyn},
although a threshold of about $\epsilon=0.001$ for synthesis is ideal for near-term quantum computers \cite{hao2025reducing}.
We then ran A* search with a batch size of 100 and a path weight of 1.0 and compared the results with \textbf{trasyn}.
Both A* search and \textbf{trasyn} were able to find a circuit in all cases, usually in less than a second.
The results in Figure \ref{fig:benchmark} (a) show that A* search is able to find the optimal T-count circuit
in about $90\%$ of cases, and is only off by one or two $T$ gates when wrong. 
However, A* search is able to find a circuit with a better gate count in about $70\%$ of cases.
This is likely because \textbf{trasyn} optimizes $T$-count, but does not place the same importance on overall gate count,
since $T$ gates are considered much more expensive than Clifford gates.



\subsection{Multi-Qubit Synthesis}


For multi-qubit synthesis we found the best performance with the matrix representation and NeRF encoding.
We trained a model with a threshold of $\epsilon=0.5$.
We ran A* search with a batch size of 100 and a path weight of 1.0, and compare the circuits with those generated
with \textbf{trasyn}.
Given that \textbf{trasyn} cannot directly synthesize two-qubit circuits, we first have to decompose
each two-qubit unitary into a sequence of one-qubit unitaries and CNOT gates,
and then use \textbf{trasyn} to synthesize those one-qubit unitaries.
This process is shown in Figure \ref{fig:trasyn_multi_process}.
We find that directly synthesizing circuits with A* search dramatically outperforms \textbf{trasyn},
reducing gate count and $T$ count by about a factor of 3 on average, shown in Figure \ref{fig:benchmark} (b).






%% SECTION Discussion and Future Work
\section{Discussion and Future Work}

This work only considers unitary operations, but some quantum computers now support dynamic circuits,
which involve measurements during the circuit and further operations conditioned on the measurement outcomes.
Previous work has shown that repeat-until-success circuits can be
used to create more optimal fault-tolerant gates \cite{bocharov2015efficient}.
‘Magic’ state distillation \cite{bravyi2005universal} has also been explored as a potential
way of implementing non-Clifford gates fault-tolerantly.
The measurement-based quantum computing paradigm even offers an alternative to the unitary quantum circuit model,
where the same ‘resource state’ is prepared every time, and computation is carried out exclusively by measurements
\cite{briegel2009measurement}.
Future work could involve expanding the search space to include those more exotic circuits.

Our approach gives the desired quantum algorithm as a goal to the heuristic function.
There may be cases where only partial information of the properties the quantum algorithm should have are known.
In these cases, this could correspond to not knowing all entries in the matrix that represents the algorithm.
Work on generalizing over goals can be used to train a heuristic function that can be given a partially
specified algorithm by having a special indicator for entries that are not known or through abstractions based on formal
logic \cite{agostinelli2024specifying}.



%% SECTION Conclusion
\section{Conclusion}

Efficient unitary synthesis will be crucial to fault-tolerant quantum computing in the near future,
allowing programmers to translate their high-level algorithm descriptions to low-level implementations on quantum hardware.
We extend DeepCubeA and HER to learn a domain-specific heuristic to
estimate cost-to-go from a given algorithm to a given goal algorithm for the Clifford+T gate set.
We then use this heuristic function in combination with BWAS to find circuits that implement the given goal algorithm.
We compare the results of BWAS with a state-of-the-art unitary synthesis program.
Future work could achieve improvements by finding a better encoding for unitary matrices
and extending the algorithm to allow for synthesis of partial specifications and dynamic circuits.



\appendix


\section{Quaternion Encoding}


Quaternions have been explored as an alternative encoding method for single-qubit unitary matrices \cite{alam2023quantum}.
The quaternions are the group of numbers $a+bi+cj+dk$ where $a,b,c,d$ are scalers and $i,j,k$ are the
unit quaternions, with the relationship $i^2=j^2=k^2=ijk=-1$.
They can be used to represent a matrix $A \in SU(2)$ by using the relationship
\begin{equation}
	A =
	\begin{bmatrix}
		a+ib & c+id \\
		-c+id & a-ib
	\end{bmatrix}
\end{equation}
This reduces the 8 components of the matrix (4 real, 4 imaginary) down to 4 components.


\section{Euler Angle Encoding}

\begin{algorithm}[tb]
    \caption{
        Procedure for Euler angle encoding of a unitary matrix $A$.
        Here $\Theta(k)$ represents initialization of an all zero array of size $k$,
        the operator $X ~@_{i,j}~ Y$ represents the block multiplication
        of a $2 \times 2$ matrix $X$ along rows $i,j$ of matrix $Y$,
        and the `diagonal' function selects the diagonal elements of a matrix.
    }

    \label{alg:euler}

    \textbf{Input}: unitary matrix $A \in U(n)$ \\
    \textbf{Output}: real vectors $\theta,\phi \in [0, 2\pi)^k$, $\lambda \in [0, 2\pi)^n$

    \begin{algorithmic}[1]
        \STATE $k \gets \lfloor n(n-1)~/~2 \rfloor$
        \STATE $\theta, \phi \gets \Theta(k)$
        \STATE $x \gets 1$ 
        \FOR {$i \in [1\dots(n-1)]$}
            \FOR {$j \in [n \dots (i+1)]$}
                \STATE $a \gets A_{i,i}$
                \STATE $b \gets A_{j,i}$
                \IF {$b \neq 0$}
                    \STATE $r \gets \sqrt{|a|^2+|b|^2}$
                    \STATE $c \gets |a| ~/~ r$
                    \STATE $s \gets |b| ~/~ r$
                    \IF {$a \neq 0$}
                        \STATE $\theta_x \gets \arctan (s~/~c)$
                        \STATE $\phi_x \gets \arg (a) - \arg (b)$
                    \ELSE
                        \STATE $\theta_x \gets \pi/2$
                        \STATE $\phi_x \gets - \arg (b)$
                    \ENDIF
                    \STATE $G \gets \begin{bmatrix} c & e^{i\phi_x}s \\ -e^{-i\phi_x}s & c \end{bmatrix}$
                    \STATE $A \gets G ~@_{i,j}~ A$
                \ENDIF
                \STATE $x \gets x + 1$
            \ENDFOR
        \ENDFOR
        \STATE $d \gets \text{diagonal}(A)$
        \STATE $\lambda \gets \arg(d)$
    \end{algorithmic}
\end{algorithm}

The generalized Euler angle encoding \cite{diaconis2017hurwitz} of a unitary matrix is the unique decomposition
of a matrix $A \in U(n)$ into $n^2$ angles ranging from $0$ to $2\pi$ given by algorithm \ref{alg:euler}.
For the purpose of quantum circuit synthesis, the global phase can also be removed by first projecting the unitary
matrix into a special unitary matrix and then disregarding the last angle in $\lambda$, leaving $n^2-1$ angles remaining.
Euler angle decomposition has been explored in the context of single-qubit synthesis \cite{alam2023quantum},
but to our knowledge we are the first to apply a generalized version to multi-qubit synthesis.



% Uncomment the following to link to your code, datasets, an extended version or similar.
% You must keep this block between (not within) the abstract and the main body of the paper.
% \begin{links}
%     \link{Code}{https://aaai.org/example/code}
%     \link{Datasets}{https://aaai.org/example/datasets}
%     \link{Extended version}{https://aaai.org/example/extended-version}
% \end{links}

\bibliography{refs.bib,forest.bib}



\end{document}
