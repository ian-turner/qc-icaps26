\documentclass[letterpaper]{article} % DO NOT CHANGE THIS
\usepackage[submission]{aaai2026}  % DO NOT CHANGE THIS
\usepackage{times}  % DO NOT CHANGE THIS
\usepackage{helvet}  % DO NOT CHANGE THIS
\usepackage{courier}  % DO NOT CHANGE THIS
\usepackage[hyphens]{url}  % DO NOT CHANGE THIS
\usepackage{graphicx} % DO NOT CHANGE THIS
\urlstyle{rm} % DO NOT CHANGE THIS
\def\UrlFont{\rm}  % DO NOT CHANGE THIS
\usepackage{natbib}  % DO NOT CHANGE THIS AND DO NOT ADD ANY OPTIONS TO IT
\usepackage{caption} % DO NOT CHANGE THIS AND DO NOT ADD ANY OPTIONS TO IT
\frenchspacing  % DO NOT CHANGE THIS
\setlength{\pdfpagewidth}{8.5in} % DO NOT CHANGE THIS
\setlength{\pdfpageheight}{11in} % DO NOT CHANGE THIS
%
% These are recommended to typeset algorithms but not required. See the subsubsection on algorithms. Remove them if you don't have algorithms in your paper.
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath,amsfonts,amssymb}

%
% These are are recommended to typeset listings but not required. See the subsubsection on listing. Remove this block if you don't have listings in your paper.
\usepackage{newfloat}
\usepackage{listings}
\DeclareCaptionStyle{ruled}{labelfont=normalfont,labelsep=colon,strut=off} % DO NOT CHANGE THIS
\lstset{%
	basicstyle={\footnotesize\ttfamily},% footnotesize acceptable for monospace
	numbers=left,numberstyle=\footnotesize,xleftmargin=2em,% show line numbers, remove this entire line if you don't want the numbers.
	aboveskip=0pt,belowskip=0pt,%
	showstringspaces=false,tabsize=2,breaklines=true}
\floatstyle{ruled}
\newfloat{listing}{tb}{lst}{}
\floatname{listing}{Listing}
%
% Keep the \pdfinfo as shown here. There's no need
% for you to add the /Title and /Author tags.
\pdfinfo{
/TemplateVersion (2026.1)
}

% DISALLOWED PACKAGES
% \usepackage{authblk} -- This package is specifically forbidden
% \usepackage{balance} -- This package is specifically forbidden
% \usepackage{color (if used in text)
% \usepackage{CJK} -- This package is specifically forbidden
% \usepackage{float} -- This package is specifically forbidden
% \usepackage{flushend} -- This package is specifically forbidden
% \usepackage{fontenc} -- This package is specifically forbidden
% \usepackage{fullpage} -- This package is specifically forbidden
% \usepackage{geometry} -- This package is specifically forbidden
% \usepackage{grffile} -- This package is specifically forbidden
% \usepackage{hyperref} -- This package is specifically forbidden
% \usepackage{navigator} -- This package is specifically forbidden
% (or any other package that embeds links such as navigator or hyperref)
% \indentfirst} -- This package is specifically forbidden
% \layout} -- This package is specifically forbidden
% \multicol} -- This package is specifically forbidden
% \nameref} -- This package is specifically forbidden
% \usepackage{savetrees} -- This package is specifically forbidden
% \usepackage{setspace} -- This package is specifically forbidden
% \usepackage{stfloats} -- This package is specifically forbidden
% \usepackage{tabu} -- This package is specifically forbidden
% \usepackage{titlesec} -- This package is specifically forbidden
% \usepackage{tocbibind} -- This package is specifically forbidden
% \usepackage{ulem} -- This package is specifically forbidden
% \usepackage{wrapfig} -- This package is specifically forbidden
% DISALLOWED COMMANDS
% \nocopyright -- Your paper will not be published if you use this command
% \addtolength -- This command may not be used
% \balance -- This command may not be used
% \baselinestretch -- Your paper will not be published if you use this command
% \clearpage -- No page breaks of any kind may be used for the final version of your paper
% \columnsep -- This command may not be used
% \newpage -- No page breaks of any kind may be used for the final version of your paper
% \pagebreak -- No page breaks of any kind may be used for the final version of your paperr
% \pagestyle -- This command may not be used
% \tiny -- This is not an acceptable font size.
% \vspace{- -- No negative value may be used in proximity of a caption, figure, table, section, subsection, subsubsection, or reference
% \vskip{- -- No negative value may be used to alter spacing above or below a caption, figure, table, section, subsection, subsubsection, or reference

% User-added config
\graphicspath{{ ./images }}
\usepackage{subcaption}
\usepackage{cite}

\setcounter{secnumdepth}{2} %May be changed to 1 or 2 if section numbers are desired.

% The file aaai2026.sty is the style file for AAAI Press
% proceedings, working notes, and technical reports.
%

% Title

% Your title must be in mixed case, not sentence case.
% That means all verbs (including short verbs like be, is, using,and go),
% nouns, adverbs, adjectives should be capitalized, including both words in hyphenated terms, while
% articles, conjunctions, and prepositions are lower case unless they
% directly follow a colon or long dash
\title{Quantum Circuit Synthesis with Deep Reinforcement Learning and Heuristic Search}
\author{
    %Authors
    % All authors must be in the same font size and format.
    Written by AAAI Press Staff\textsuperscript{\rm 1}\thanks{With help from the AAAI Publications Committee.}\\
    AAAI Style Contributions by Pater Patel Schneider,
    Sunil Issar,\\
    J. Scott Penberthy,
    George Ferguson,
    Hans Guesgen,
    Francisco Cruz\equalcontrib,
    Marc Pujol-Gonzalez\equalcontrib
}
\affiliations{
    %Afiliations
    \textsuperscript{\rm 1}Association for the Advancement of Artificial Intelligence\\
    % If you have multiple authors and multiple affiliations
    % use superscripts in text and roman font to identify them.
    % For example,

    % Sunil Issar\textsuperscript{\rm 2},
    % J. Scott Penberthy\textsuperscript{\rm 3},
    % George Ferguson\textsuperscript{\rm 4},
    % Hans Guesgen\textsuperscript{\rm 5}
    % Note that the comma should be placed after the superscript

    1101 Pennsylvania Ave, NW Suite 300\\
    Washington, DC 20004 USA\\
    % email address must be in roman text type, not monospace or sans serif
    proceedings-questions@aaai.org
%
% See more examples next
}

%Example, Single Author, ->> remove \iffalse,\fi and place them surrounding AAAI title to use it
\iffalse
\title{My Publication Title --- Single Author}
\author {
    Author Name
}
\affiliations{
    Affiliation\\
    Affiliation Line 2\\
    name@example.com
}
\fi

\iffalse
%Example, Multiple Authors, ->> remove \iffalse,\fi and place them surrounding AAAI title to use it
\title{My Publication Title --- Multiple Authors}
\author {
    % Authors
    First Author Name\textsuperscript{\rm 1},
    Second Author Name\textsuperscript{\rm 2},
    Third Author Name\textsuperscript{\rm 1}
}
\affiliations {
    % Affiliations
    \textsuperscript{\rm 1}Affiliation 1\\
    \textsuperscript{\rm 2}Affiliation 2\\
    firstAuthor@affiliation1.com, secondAuthor@affilation2.com, thirdAuthor@affiliation1.com
}
\fi


% REMOVE THIS: bibentry
% This is only needed to show inline citations in the guidelines document. You should not need it and can safely delete it.
\usepackage{bibentry}
% END REMOVE bibentry

\begin{document}

\maketitle

\begin{abstract}
Quantum circuit synthesis is the process of implementing
a quantum algorithm with a given gate set. In this
paper, we first show how this problem can be posed as a
pathfinding problem. Next, we use DeepCubeA to learn a
heuristic function for quantum circuit synthesis for one to
three qubit circuits with deep reinforcement learning and
solve problem instances with batch weighed A* search. We
compare our approach against a state-of-the-art
quantum circuit synthesis tool and show that are our
approach is competitive.
\end{abstract}



%% SECTION Introduction
\section{Introduction}


\begin{figure}[h!]
	\centering
	\includegraphics[width=0.4\textwidth]{images/qc_ex.png}
	\caption{Example of a quantum circuit composed of Clifford and T gates}
	\label{fig:toffoli}
\end{figure}

The realization of quantum algorithms on real-world quantum computers is accomplished through
quantum compiling \cite{maronese2022quantum}, also known as quantum circuit synthesis.
Given a quantum algorithm, quantum compiling finds a quantum circuit that implements that algorithm.
A quantum algorithm can be represented as a matrix of size $2^n \times 2^n$, with $n$ being the number of qubits.
A quantum circuit (Figure \ref{fig:toffoli}) is a sequence of gates that perform operations on one or more qubits,
where a qubit is an irreducible unit of quantum information.
Given a quantum circuit, the matrix that represents the algorithm it implements is obtained by starting with the
identity matrix and changing its entries according to matrix multiplications determined by the gates used in the circuit.
As a result, quantum compiling can be posed as a pathfinding problem, where the start state
is the identity matrix, the goal is a given quantum algorithm, the transitions are quantum gates, and the transition costs
are determined by a combination of quantum gate execution time and the noise the gate introduces.


Finding quantum circuits that implement a given algorithm is a non-trivial task that can sometimes take state-of-the-art
methods several hours, even for single qubit operators \cite{paradis2024synthetiq}.
Given that we can pose this as a pathfinding problem, we build on the DeepCubeA algorithm \cite{agostinelli2019solving}
and hindsight experience replay (HER) \cite{andrychowicz2017hindsight} to use deep reinforcement learning to learn
a heuristic function that maps a given quantum circuit and quantum goal algorithm to an estimate of the cost of a
shortest path (i.e. ``cost-to-go'') from the given circuit to a circuit that implements the goal algorithm.
Previous work that has built on DeepCubeA to perform quantum compiling used the reversibility of quantum gates
to set the starting state to be the quantum algorithm and the goal to be the identity matrix
\cite{zhang2020topological,bao2024twisty,chen2024efficient}.
Our work distinguishes itself from this previous work since the starting state is the identity matrix and the goal is
given as the quantum algorithm.
This distinction then allows our approach to be modified for the specification of goals as
a set of goal states through partial specification of goal matrix entries or through abstraction using formal logic.
This may be necessary if certain properties of the algorithm (i.e. entries in the matrix) are known while other parts are not
known or not relevant.
These modifications that allow for this are already present in existing literature \cite{agostinelli2024specifying}
and can be applied to the work presented in the paper.




%% SECTION Background
\section{Background}


\subsection{Quantum Computing}


\paragraph{Qubits}

A qubit is the fundamental unit of information in quantum computing.
We can represent any system of $n$ qubits as a unit vector $|\psi\rangle \in \mathbb{C}^{2^n}$.
The $0$ and $1$ states for a single qubit can be represented as

\begin{equation}
	|0\rangle = \begin{bmatrix} 1 \\ 0 \end{bmatrix}
	,~~~~
	|1\rangle = \begin{bmatrix} 0 \\ 1 \end{bmatrix}
\end{equation}

and a general one-qubit quantum state can be represented as $\alpha|0\rangle + \beta|1\rangle$,
where $\alpha,\beta\in\mathbb{C}$ and $|\alpha|^2+|\beta|^2=1$.
It is important to note that if two quantum state vectors differ only by a complex
phase (meaning $|\psi\rangle=e^{i\theta}|\phi\rangle$ for two state vectors $|\psi\rangle$ and $|\phi\rangle$),
then the two states cannot be distinguished in any way by measurement.
For this reason, it is common to disregard global phases in calculations or modify them as needed for convenience
\cite{nielsen2010quantum}.


Multiple qubit systems can be represented using the tensor product.
The tensor product between two matrices $A \in \mathbb{C}^{m_1 \times n_1},B \in \mathbb{C}^{m_2 \times n_2}$
is defined as the block matrix
\begin{equation}
	A \otimes B =
	\begin{bmatrix}
		a_{11} B   & \dots  & a_{1n_1} B    \\
		\vdots     & \ddots & \vdots        \\
		a_{m_11} B & \dots  &  a_{m_1n_1} B \\
	\end{bmatrix}
	\in \mathbb{C}^{m_1m_2 \times n_1n_2}.
\end{equation}
The basis states of an $n$-qubit system can be represented using a tensor product of $n$ one-qubit states,
for example $|011\rangle = |0\rangle \otimes |1\rangle \otimes |1\rangle$.


\paragraph{Gates}

Quantum gates transform quantum states into new states.
Disregarding measurement operations, a quantum gate can be represented by a unitary matrix $U \in \mathbb{C}^{2^n \times 2^n}$.
A matrix is unitary if $UU^{\dagger}=U^{\dagger}U=I$, where $U^{\dagger}$ is the conjugate transpose of $U$.
As a consequence of the global phase invariance of quantum states, two gates whose unitaries differ only by a complex
phase are also considered equivalent.

There are many methods for calculating the `distance' between two unitary operators.
In this paper we use the Hilbert-Schmidt distance function

\begin{equation}
	d(U,V) = \sqrt{1 - \frac{1}{4^n} |Tr(U^{\dagger}V)|^2}
\end{equation}

This method has the advantage that if two unitaries $A$ and $B$ differ only by a global phase, then $d(A,B)=0$.


\paragraph{Clifford+T Gate Set}


\paragraph{Unitary Synthesis}



\subsection{Pathfinding}
Pathfinding is the process of finding a sequence of actions that forms a path between a given start state and a given goal, where a goal is a set of states considered goal states. A pathfinding domain is defined by a weighted directed graph, where nodes represent states, edges represent transitions between states, and weights represent transition costs \cite{pohl1970heuristic}. The transitions can be thought of as resulting from a set of actions, $\mathcal{A}$, and the transition function function, $T$, returns state, $s'$, given state, $s$, and action, $a$, if and only if there is an edge between state $s$ and $s'$ for some action, $a$ (i.e. $s' = T(s,a)$). The transition cost function, $c$, returns the cost of taking action, $a$, in states, $s$ (i.e. $c(s,a)$). Given a domain, a pathfinding problem instance is defined by a start state and a goal. Given a path that is a solution to a problem instance, the path cost is the sum of transition costs. In this work, the states are matrices representing quantum algorithms, transitions are the application of quantum gates, which produce new matrices, and transition costs are 1 for all gates. In future work, we will consider assigning a higher transition cost to gates, such as the $T$ gate, which add more execution time or noise to the circuit.

\subsubsection{Heuristic Search}
A* search \cite{hart1968formal} is a search algorithm designed to find a path between two nodes in a weighted directed graph. Similar to other algorithms like depth-first search and Djikstra's algorithm, A* keeps a priority queue of nodes, ordered from least to greatest according
to the function
\begin{equation}
    f(n)=g(n)+h(n)
\end{equation}
where $g(n)$ is the path cost (sum of all transition costs taken to reach node
$n$ and $h(n)$ is the heuristic function value of state associated with $n$.

While searching each node keeps track of the path cost and heuristic function value
as well as a connection to its parent node and the action taken to generate the state from its parent. The A* search process is begun when a single node with no parents representing the start state is added to the queue, and is ended once a node associated with a goal state is selected for expansion or there are no more nodes to expand.

In practice, a significant speedup can be achieved with heuristic functions represented by neural networks by batching the expansion steps together and exploiting the parallelism of graphics processing units (GPUs), as well as modifying the cost function to be $f(n)=\lambda g(n)+h(n)$,
where $\lambda \in [0,1]$ can be adjusted to place less important on the path cost of a state and more on the heuristic value. This batched and weighted version of A* search is referred to as batch weighted A* search (BWAS).

\subsection{DeepCubeA}

DeepCubeA \cite{agostinelli2019solving} is an algorithm that learns a domain-specific heuristic function represented as a deep neural network (DNN) \cite{schmidhuber2015deep,lecun2015deep} using deep reinforcement learning \cite{sutton2018reinforcement}, which is then used with BWAS to solve problem instances. While DeepCubeA originally assumed the goal was known before training and took transitions in reverse from the goal, extensions have built on hindsight experience replay (HER) \cite{andrychowicz2017hindsight} to learn heuristic functions that generalize over both states and goals \cite{agostinelli2024specifying,agostinelli2024learning}.

\subsubsection{Learning the Heuristic Function}
The heuristic function is learned with approximate value iteration \cite{puterman1978modified,bertsekas1996neuro}, which iteratively trains a model to approximate a Bellman update for a set of problem instances. The Bellman update, in the context of pathfinding (shown in Equation \ref{eq:bellmanup}) uses the Bellman optimality equation as an update rule. Approximate value iteration can be used to train a DNN, $h_\theta$, with parameters $\theta$, with gradient descent using the loss function in Equation \ref{eq:viloss}, where $N$ is the batch size. The heuristic function used to calculate the Bellman update in Equation \ref{eq:bellmanup} is $h_{\theta^-}$, where $\theta^-$ is the parameters of the target network \cite{mnih2015human} which are periodically updated to $\theta$. Approximate value iteration with DNNs is referred to as deep approximate value iteration (DAVI).

\begin{equation} \label{eq:bellmanup}
	\small
	h'(s,g) =
	\begin{cases}
		0, & \text{if } s \in g, \\
		\min\limits_{a \in \mathcal{A}}{c(s,a) + h(T(s,a),g)}, & \text{otherwise}.
	\end{cases}
\end{equation}


\begin{equation} \label{eq:viloss}
	L({\theta}) = \frac{1}{N}\sum_{i}^N{(h'(s_i,g_i) - h_{\theta}(s_i,g_i))^2}
\end{equation}


We build on hindsight experience replay (HER) \cite{andrychowicz2017hindsight} to generate start state and goal pairs without having to start from a predetermined goal and take actions in reverse. We accomplish this by first starting with the identity matrix and taking random actions to generate a start state. From this generated start state, we then take random actions to generate a goal state.




%% SECTION Related work
\section{Related Work}




%% SECTION Approach
\section{Approach}




%% SECTION Experiments
\section{Experiments}



\begin{figure}

	\begin{subfigure}{0.48\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/training1q}
		\caption{Training progress for different state encoding methods on 1-qubit synthesis with $\epsilon=0.01$}
	\end{subfigure}

	\caption{Training progress for different models}
	\label{fig:training}

\end{figure}



\begin{figure*}
	\begin{subfigure}{0.2\textwidth}
		\includegraphics[width=\textwidth]{images/qc_U}
		\caption{Arbitrary 2-qubit unitary}
	\end{subfigure}
	\begin{subfigure}{0.76\textwidth}
		\includegraphics[width=\textwidth]{images/qc_U3}
		\caption{Unitary decomposed into arbitrary 1-qubit unitaries and CNOTs}
	\end{subfigure}
	\\
	\begin{subfigure}{\textwidth}
		\includegraphics[width=\textwidth]{images/qc_tr}
		\caption{Final compiled circuit after synthesizing each 1-qubit unitary with \textbf{trasyn}}
	\end{subfigure}
	\caption{Process for synthesis of multi-qubit circuits using \textbf{trasyn}}
	\label{fig:trasyn_multi_process}
\end{figure*}






\begin{figure}
	\centering

	\begin{subfigure}{0.48\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/1q-bench}
		\caption{1-qubit synthesis with $\epsilon=0.01$}
	\end{subfigure}

	\begin{subfigure}{0.48\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/2q-bench}
		\caption{2-qubit synthesis with $\epsilon=0.5$}
	\end{subfigure}

	\caption{A* search vs \textbf{trasyn} for synthesis of arbitrary 1, 2, and 3-qubit unitaries}
\end{figure}




%% SECTION Discussion and Future Work
\section{Discussion and Future Work}




%% SECTION Conclusion
\section{Conclusion}



\appendix

\section{Hurwitz Encoding}

\begin{algorithm}[tb]
    \caption{
        Procedure for Hurwitz encoding of a unitary matrix $A$.
        Here $\Theta(k)$ represents initialization of an all zero array of size $k$,
        the operator $X ~@_{i,j}~ Y$ represents the block multiplication
        of a $2 \times 2$ matrix $X$ along rows $i,j$ of matrix $Y$,
        and the `diagonal' function selects the diagonal elements of a matrix.
    }

    \label{alg:hurwitz}

    \textbf{Input}: unitary matrix $A \in U(n)$ \\
    \textbf{Output}: real vectors $\theta,\phi \in [0, 2\pi)^k$, $\lambda \in [0, 2\pi)^n$

    \begin{algorithmic}[1]
        \STATE $k \gets \lfloor n(n-1)~/~2 \rfloor$
        \STATE $\theta \gets \Theta(k)$
        \STATE $\phi \gets \Theta(k)$
        \STATE $x \gets 1$ 
        \FOR {$i \in [1\dots(n-1)]$}
            \FOR {$j \in [n \dots (i+1)]$}
                \STATE $a \gets A_{i,i}$
                \STATE $b \gets A_{j,i}$
                \IF {$b \neq 0$}
                    \STATE $r \gets \sqrt{|a|^2+|b|^2}$
                    \STATE $c \gets |a| ~/~ r$
                    \STATE $s \gets |b| ~/~ r$
                    \IF {$a \neq 0$}
                        \STATE $\theta_x \gets \arctan (s~/~c)$
                        \STATE $\phi_x \gets \arg (a) - \arg (b)$
                    \ELSE
                        \STATE $\theta_x \gets \pi/2$
                        \STATE $\phi_x \gets - \arg (b)$
                    \ENDIF
                    \STATE $G \gets \begin{bmatrix} c & e^{i\phi_x}s \\ -e^{-i\phi_x}s & c \end{bmatrix}$
                    \STATE $A \gets G ~@_{i,j}~ A$
                \ENDIF
                \STATE $x \gets x + 1$
            \ENDFOR
        \ENDFOR
        \STATE $d \gets \text{diagonal}(A)$
        \STATE $\lambda \gets \arg(d)$
    \end{algorithmic}
\end{algorithm}

The generalized Euler angle encoding, or `Hurwitz' encoding of a unitary matrix is the unique decomposition
of a matrix $A \in U(n)$ into $n^2$ angles ranging from $0$ to $2\pi$ given by algorithm \ref{alg:hurwitz}.
Note that the pseudocode contains comparisons to 0, but in practice the values are compared within a tolerance value to ensure numerical stability.
For the purpose of quantum circuit synthesis, the global phase can also be removed by first projecting the unitary
matrix into a special unitary matrix according to the function $\Pi : U(n) \rightarrow SU(n)$, defined as
$\Pi (A) = e^{-i (\arg(\text{det}(A)))/n} A$.
The last angle in $\lambda$ can then be disregarded, and the resulting representation will contain $n^2-1$ angles.



% Uncomment the following to link to your code, datasets, an extended version or similar.
% You must keep this block between (not within) the abstract and the main body of the paper.
% \begin{links}
%     \link{Code}{https://aaai.org/example/code}
%     \link{Datasets}{https://aaai.org/example/datasets}
%     \link{Extended version}{https://aaai.org/example/extended-version}
% \end{links}

\bibliography{refs.bib,forest.bib}



\end{document}
